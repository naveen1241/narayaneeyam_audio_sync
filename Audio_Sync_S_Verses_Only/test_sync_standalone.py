import json
import argparse
import os # <-- ADD THIS IMPORT
from typing import Dict, Any

def create_srt_from_recitation(recitation: Dict[str, Any], output_path: str):
    """
    Creates an SRT file from a single recitation's verse data.
    
    Args:
        recitation: The dictionary for a single recitation.
        output_path: The file path to save the .srt file.
    """
    verses = recitation.get('verses', [])
    if not verses:
        print(f"Warning: No verses found for recitation '{recitation.get('id')}'. Skipping SRT creation.")
        return

    with open(output_path, "w", encoding="utf-8") as f:
        num_verses = len(verses)
        for i in range(num_verses):
            verse = verses[i]
            start_time = verse.get('time')
            
            if start_time is None:
                continue

            # Determine the end time for the current verse
            if i + 1 < num_verses:
                # The end time of the current verse is the start time of the next verse
                end_time = verses[i+1].get('time')
            else:
                # For the last verse, use the last word's timestamp
                last_word = verse.get('words', [])[-1] if verse.get('words') else None
                if last_word and last_word.get('time') is not None:
                    end_time = last_word.get('time')
                else:
                    # Fallback if no last word time is available
                    end_time = start_time + 5.0
            
            if end_time is None:
                continue

            # Format time for SRT: HH:MM:SS,mmm
            def format_time(seconds):
                millis = int((seconds % 1) * 1000)
                seconds = int(seconds)
                hours, seconds = divmod(seconds, 3600)
                minutes, seconds = divmod(seconds, 60)
                return f"{hours:02}:{minutes:02}:{seconds:02},{millis:03}"

            f.write(f"{i + 1}\n")
            f.write(f"{format_time(start_time)} --> {format_time(end_time)}\n")
            
            # Reconstruct the line-broken text for the SRT file
            text_lines = []
            current_line = ""
            for word_data in verse['words']:
                if word_data['text'] == "<br>":
                    if current_line:
                        text_lines.append(current_line.strip())
                    current_line = ""
                else:
                    current_line += word_data['text'] + " "
            if current_line:
                text_lines.append(current_line.strip())
            
            if text_lines:
                f.write("\n".join(text_lines))
            else:
                f.write(" ")
            f.write("\n\n")

def main():
    parser = argparse.ArgumentParser(description="Test audio sync for a single MP3 and JSON pair.")
    parser.add_argument("mp3_file", help="Path to the MP3 audio file.")
    parser.add_argument("json_file", help="Path to the JSON file generated by the alignment script.")
    args = parser.parse_args()

    try:
        with open(args.json_file, "r", encoding="utf-8") as f:
            recitations_data = json.load(f)

        if not recitations_data:
            print(f"Error: JSON file '{args.json_file}' is empty or not in the expected format.")
            return

        target_recitation = None
        for recitation in recitations_data:
            if args.mp3_file.split(os.path.sep)[-1] == recitation.get('audio'):
                target_recitation = recitation
                break
        
        if not target_recitation:
            print(f"Error: Could not find data for '{args.mp3_file}' in the JSON file.")
            return

        srt_output_filename = f"{target_recitation['id']}_test.srt"
        create_srt_from_recitation(target_recitation, srt_output_filename)
        
        print(f"\nSRT file '{srt_output_filename}' created for testing.")
        print(f"To test, play '{args.mp3_file}' in a media player like VLC with '{srt_output_filename}' loaded as a subtitle track.")
        print("Visually verify if the text appears in sync with the audio.")
            
    except (IOError, json.JSONDecodeError) as e:
        print(f"Error reading or parsing files: {e}")

if __name__ == "__main__":
    main()
